https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/RubiconMarket.sol#L578

In function calcAmountAfterFee should include checks to prevent overflows and underflows. One way to mitigate this risk is to use a SafeMath library or similar contract that provides safe arithmetic operations. SafeMath library functions such as add, sub, mul, and div can be used to ensure that the arithmetic operations do not result in overflow or underflow.
For example, instead of using _amount -= mul(amount, feeBPS) / 100_000; the SafeMath library could be used to perform the calculation as follows: _amount = SafeMath.sub(_amount, SafeMath.div(SafeMath.mul(amount, feeBPS), 100000)); Similarly, mul(amount, makerFee()) / 100_000 could be replaced with SafeMath.div(SafeMath.mul(amount, makerFee()), 100000) to prevent overflow or underflow.

https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/BathHouseV2.sol#L146

In this function _bathify concatenates the symbol of the underlying token with the string "bath" to create the Bath token name. It concatenates the Bath token name with the string "v2" to create the Bath token symbol. Finally, it retrieves the decimals value of the underlying token and returns it along with the Bath token name and symbol. Using string concatenation to generate Bath token names and symbols may make the contract vulnerable to length extension attacks, where an attacker could create a malicious token with a name or symbol that exploits the string concatenation process.
To prevent this type of attack, it is recommended to use a secure hash function, such as Keccak-256 (also known as SHA-3), to generate unique names and symbols for Bath tokens. This approach would ensure that the name and symbol are unique and not predictable, and would make it difficult for attackers to generate malicious tokens.
In practice, the function could be modified to use a hash function like Keccak-256 to generate Bath token names and symbols. For example, the function could take the hash of the underlying token's symbol and concatenate it with the string "bath" to generate the Bath token name. The Bath token symbol could be generated by concatenating the Bath token name hash with another string or a random number. Overall, using a secure hash function to generate Bath token names and symbols would provide an additional layer of security to the contract and help prevent length extension attacks.

https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/poolsUtility/Position.sol #L125

In the openposition function it does not perform sufficient input validation on function parameters, which could potentially allow an attacker to exploit the system or cause it to fail. For example, the openPosition() function does not validate that the initMargin parameter is greater than zero, which could result in a position being opened with insufficient collateral. If the initMargin parameter passed to the openPosition() function is zero, it could result in a position being opened without any collateral. This could potentially allow an attacker to exploit the system by opening large positions without any initial margin, leading to a situation where the system is unable to cover the losses if the position goes against them. It could also cause the system to fail if it is not able to handle such a scenario. Therefore, it is important to validate input parameters to ensure that they meet the expected requirements before processing them. It also does not handle errors or exceptions that may arise during execution, which could lead to unexpected behavior or failure of the contract. For example, the openPosition() function does not check for errors that may occur during borrowing, such as a failed transaction or insufficient funds, which could leave the contract in an inconsistent state.

https://github.com/code-423n4/2023-04-rubicon/blob/main/contracts/utilities/FeeWrapper.sol #L28

Adding input validation could involve ensuring that the calculateFee function is only called with valid input values for tokenAmounts, feeType, and feeValue. This could involve checking that the tokenAmounts array has a length greater than zero and that each element in the array is not zero. Other input validation checks could include verifying that the feeType and feeValue inputs are positive integers and not equal to zero, and that the resulting calculated fees do not exceed the corresponding token amounts.
 



